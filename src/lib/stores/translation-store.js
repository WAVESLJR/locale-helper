import { LOCALE_CODES } from '$lib/constants.js';
import { writable } from 'svelte/store';
import { extractStrings } from '$lib/utils/string-extraction.js';
import { reconstructJson } from '$lib/utils/json-reconstruction.js';

/**
 * The translation store holds all stages of the translation workflow:
 * 
 * MANUAL INPUTS (user can edit):
 * - sourceJson: raw JSON input that user provides/edits
 * - responseText: translated text array that user provides/edits
 * 
 * PROCESSED OUTPUTS (generated by functions):
 * - sourceText: extracted strings from sourceJson (for translation reference)
 * - responseJson: reconstructed JSON from responseText
 */
function createTranslationStore() {
  const { subscribe, set, update } = writable({
    sourceLang: LOCALE_CODES.en,     // source language
    targetLang: LOCALE_CODES.fr,     // target language
    
    // MANUAL INPUTS
    sourceJson: {},                  // User input: original JSON
    responseText: [],                // User input: array of translated strings
    
    // PROCESSED OUTPUTS  
    sourceText: [],                  // Generated: strings extracted from sourceJson
    responseJson: {},                // Generated: JSON reconstructed from responseText
    
    // INTERNAL DATA
    extractedData: [],               // Internal: full extraction data with key paths
    validationErrors: [],            // Validation issues between sourceText and responseText
    isValidated: false               // Whether responseText has been validated
  });

  return {
    subscribe,

    // Reset everything
    reset: () => set({
      sourceLang: LOCALE_CODES.en,
      targetLang: LOCALE_CODES.fr,
      sourceJson: {},
      responseText: [],
      sourceText: [],
      responseJson: {},
      extractedData: [],
      validationErrors: [],
      isValidated: false
    }),

    // Update languages
    setLanguages: (source, target) => update(state => ({
      ...state,
      sourceLang: source,
      targetLang: target
    })),

    // MANUAL INPUT: Set source JSON (user edits this)
    setSourceJson: (jsonObj) => update(state => ({
      ...state,
      sourceJson: jsonObj,
      // Clear processed outputs - need to regenerate
      sourceText: [],
      responseJson: {},
      validationErrors: [],
      isValidated: false
    })),

    // MANUAL INPUT: Set response text (user edits this)
    setResponseText: (textArray) => update(state => ({
      ...state,
      responseText: textArray,
      // Clear processed output - need to regenerate
      responseJson: {},
      validationErrors: [],
      isValidated: false
    })),

    // PROCESS: Generate sourceText from sourceJson
    processSourceJson: () => update(state => {
      try {
        const extractedData = extractStrings(state.sourceJson);
        const sourceText = extractedData.map(item => item.value);
        
        return {
          ...state,
          extractedData,
          sourceText,
          validationErrors: [],
          isValidated: false,
          // Clear responseJson since source changed
          responseJson: {}
        };
      } catch (error) {
        return {
          ...state,
          sourceText: [],
          extractedData: [],
          validationErrors: [`Failed to process source JSON: ${error.message}`]
        };
      }
    }),

    // PROCESS: Generate responseJson from responseText
    processResponseText: () => update(state => {
      // First validate that we have extracted data to work with
      if (state.extractedData.length === 0) {
        return {
          ...state,
          responseJson: {},
          validationErrors: ['No source data available. Please process source JSON first.'],
          isValidated: false
        };
      }

      // Validate responseText against sourceText
      const validationResult = validateTranslation(state.extractedData, state.responseText);
      
      if (!validationResult.isValid) {
        return {
          ...state,
          responseJson: {},
          validationErrors: validationResult.errors,
          isValidated: false
        };
      }

      // Generate responseJson
      try {
        const responseJson = reconstructJson(state.extractedData, state.responseText);
        return {
          ...state,
          responseJson,
          validationErrors: [],
          isValidated: true
        };
      } catch (error) {
        return {
          ...state,
          responseJson: {},
          validationErrors: [`Failed to reconstruct JSON: ${error.message}`],
          isValidated: false
        };
      }
    }),

    // Process both source and response (convenience method)
    processAll: () => update(state => {
      // First process source
      let newState = { ...state };
      
      try {
        const extractedData = extractStrings(newState.sourceJson);
        const sourceText = extractedData.map(item => item.value);
        newState = {
          ...newState,
          extractedData,
          sourceText,
          validationErrors: []
        };
      } catch (error) {
        return {
          ...newState,
          sourceText: [],
          extractedData: [],
          responseJson: {},
          validationErrors: [`Failed to process source JSON: ${error.message}`],
          isValidated: false
        };
      }

      // Then process response
      const validationResult = validateTranslation(newState.extractedData, newState.responseText);
      
      if (!validationResult.isValid) {
        return {
          ...newState,
          responseJson: {},
          validationErrors: validationResult.errors,
          isValidated: false
        };
      }

      try {
        const responseJson = reconstructJson(newState.extractedData, newState.responseText);
        return {
          ...newState,
          responseJson,
          validationErrors: [],
          isValidated: true
        };
      } catch (error) {
        return {
          ...newState,
          responseJson: {},
          validationErrors: [`Failed to reconstruct JSON: ${error.message}`],
          isValidated: false
        };
      }
    }),

    // Clear validation errors
    clearValidationErrors: () => update(state => ({
      ...state,
      validationErrors: []
    })),

    // Get current state (helper for components)
    getState: () => {
      let currentState;
      update(state => {
        currentState = state;
        return state;
      });
      return currentState;
    }
  };
}

/**
 * Validate that responseText matches the structure of extractedData
 */
function validateTranslation(extractedData, responseText) {
  const errors = [];
  
  // Check if arrays have same length
  if (extractedData.length !== responseText.length) {
    errors.push(`Mismatch in number of strings: expected ${extractedData.length}, got ${responseText.length}`);
    return { isValid: false, errors };
  }

  // Check each string for placeholder consistency
  for (let i = 0; i < extractedData.length; i++) {
    const original = extractedData[i];
    const translated = responseText[i];
    
    if (!translated || typeof translated !== 'string') {
      errors.push(`Line ${i + 1}: Missing or invalid translation`);
      continue;
    }

    // Extract placeholders from translated text
    const translatedPlaceholders = extractPlaceholders(translated);
    const originalPlaceholders = original.placeholders || [];
    
    // Check if placeholders match
    if (!arraysEqual(originalPlaceholders.sort(), translatedPlaceholders.sort())) {
      errors.push(`Line ${i + 1}: Placeholder mismatch. Expected: {${originalPlaceholders.join('}, {')}}, Got: {${translatedPlaceholders.join('}, {')}}`);
    }
  }

  return {
    isValid: errors.length === 0,
    errors
  };
}

/**
 * Extract placeholders from a string
 */
function extractPlaceholders(text) {
  const matches = text.match(/\{([^}]+)\}/g);
  if (!matches) return [];
  return matches.map(match => match.slice(1, -1));
}

/**
 * Check if two arrays have the same elements
 */
function arraysEqual(arr1, arr2) {
  if (arr1.length !== arr2.length) return false;
  return arr1.every((item, index) => item === arr2[index]);
}

export const translationStore = createTranslationStore();